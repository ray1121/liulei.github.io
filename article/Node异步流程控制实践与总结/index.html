<!DOCTYPE html>
<html lang="zh">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="baidu-site-verification" content="AWIlOY2Rc6" />
    <meta name="baidu-site-verification" content="NoiX8Y5AVD" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Hi~这是刘雷，USTC软件工程研二学生党一枚，JS，Node，python爱好者，web开发小学生，热爱科比热爱詹姆斯">
    <meta name="keyword" content="刘雷,刘雷的博客,原创,javascript,前端,Node,node,python,web-develop">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
            Node异步流程控制实践与总结 - 刘雷的博客 | Ray&#39;s Blog
                
    </title>

    <link rel="canonical" href="https://isliulei.com/article/Node异步流程控制实践与总结/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/hux-blog.min.css">

            <!-- Pygments Highlight CSS -->
            <link rel="stylesheet" href="/css/highlight.css">
                <link rel="stylesheet" href="/css/rocket.css">
                    <!-- Custom Fonts -->
                    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
                    <!-- Hux change font-awesome CDN to qiniu -->
                    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


                    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


                    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
                    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
                    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
                    <!-- ga & ba script hoook -->
                    <script></script>
                    <!-- Google Analytics -->

                    
</head>

<!-- hack iOS CSS :active style -->
<body ontouchstart="">
    <!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/default_bg.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                        </div>
                        <h1>Node异步流程控制实践与总结</h1>
                        <h2 class="subheading">从 “async” 到 async</h2>
                        <span class="meta">
                            Posted by Ray on
                            2018-03-06
                        </span>
                    </div>
                
                </div>
            </div>
        </div>
    </div>
</header>
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Ray</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    
                        
                        
                    
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    
                        
                        
                        <li>
                            <a href="/archives/">archives</a>
                        </li>
                        
                    
                        
                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://isliulei.com/img/icon_wechat.jpg" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->


<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="Node的异步概念"><a href="#Node的异步概念" class="headerlink" title="Node的异步概念"></a>Node的异步概念</h2><h3 id="理解异步非阻塞"><a href="#理解异步非阻塞" class="headerlink" title="理解异步非阻塞"></a>理解异步非阻塞</h3><p>提到Node，<strong>异步非阻塞</strong>会是第一个需要你理解的概念。很多人会把这实际上是两个概念的词混为一谈，认为异步就是非阻塞的，而同步就是阻塞的。从实际的效果出发，异步IO和非阻塞IO实际上都能达到我们对于IO繁重的网络应用并行IO的追求。但是实际上这是两个很不一样的概念。</p>
<p><strong>从操作系统的内核角度出发</strong>，I/O调用<strong>只有两种方式，阻塞和非阻塞</strong>。二者的区别在于，对于使用阻塞IO调用，应用程序需要等待IO的整个过程都全部完成，即完成整个IO目的，此期间CPU进行等待，无法得到充分的利用。而对于使用非阻塞IO调用来说，应用程序发起IO请求之后不等待数据就立即返回，接下来的CPU时间片可用于其他任务，由于整个IO的过程并没有完成，所以还需要使用<strong>轮询技术</strong>去试探数据是否完整准备好。关于轮询技术细节和发展，此处不过多赘述，很推荐朴灵老师《深入浅出NodeJs》的第三章。</p>
<p>不难理解，<strong>从应用程序的角度出发</strong>，我不管你操作系统内核是阻塞的IO调用还是非阻塞的IO调用，只要是我要的数据并没有给我，那么这就是同步的，因为我依旧是在等数据。所以对于这种情况下，应用程序的那“一根筋”就可以选择用同步还是异步的方式去面对该情况。同步即等待操作系统给到数据再进行下面的代码（单线程），异步即发出请求之后也立即返回，用某一种方式注册未完成的任务（回调函数）然后继续往下执行代码。</p>
<h2 id="理解进程，线程，协程"><a href="#理解进程，线程，协程" class="headerlink" title="理解进程，线程，协程"></a>理解进程，线程，协程</h2><p><strong>为了使多个程序能够并发</strong>（同一时刻只有一个在运行，时间维度稍微拉长，就会感觉起来像多个同时运行）便有了这个在操作系统中能够独立运行并作为<strong>资源分配的基本单位</strong>。</p>
<p>进程是资源分配的基本单位，进程的调度涉及到的内容比较多（存储空间，CPU，I/O资源等，进程现场保护），<strong>调度开销较大</strong>，在并发的切换过程效率较低。为了更高效的进行调度，提出了比进程更轻量的独立运行和调度的基本单位<strong>线程</strong>。最主要的一点<strong>同一个进程的多个线程共享进程的资源</strong>，这就会暴露出一个多线程编程中需要加入多线程的<strong>锁机制来控制资源的互斥性</strong>（同时写变量冲突）。线程调度能大幅度减小调度的成本（相对于进程来说），线程的切换不会引起进程的切换，但是毕竟还是有成本。</p>
<p>面对着线程相关的问题，出现了<strong>协程</strong>。协程是用户模式下的<strong>轻量级线程</strong>，<strong>操作系统内核对协程一无所知</strong>，协程的调度<strong>完全有应用程序来控制</strong>，操作系统不管这部分的调度。</p>
<p>协程的特点在于是<strong>一个线程执行</strong>，因此最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。第二大优势就是不需要多线程的锁机制，因为只有一个线程，就也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>依据上述概念本身我们可能可以得出一种暂时性的结论：<strong>考虑到利用多核CPU，并且充分发挥协程的高效率，又可获得极高的性能，面向开发人员最简单的方法是多进程+协程，既充分利用多核</strong></p>
<p>在Node中利用多核CPU的子进程<a href="http://nodejs.cn/api/child_process.html" target="_blank" rel="noopener">文档</a></p>
<h2 id="回调函数问题"><a href="#回调函数问题" class="headerlink" title="回调函数问题"></a>回调函数问题</h2><p>在Node中每一个异步的IO回调函数并不是由开发人员所控制主动执行的。</p>
<h4 id="那么对于Node的异步IO，在我们最常使用的异步回调的形式下，我们发出调用到回调函数执行这中间发生了什么？"><a href="#那么对于Node的异步IO，在我们最常使用的异步回调的形式下，我们发出调用到回调函数执行这中间发生了什么？" class="headerlink" title="那么对于Node的异步IO，在我们最常使用的异步回调的形式下，我们发出调用到回调函数执行这中间发生了什么？"></a>那么对于Node的异步IO，在我们最常使用的异步回调的形式下，我们发出调用到回调函数执行这中间发生了什么？</h4><p>整个过程可简单的抽象成四个基本要素：<strong>IO线程池</strong>，<strong>观察者</strong>，<strong>请求对象</strong>，以及<strong>事件循环</strong>，盗用《深入浅出NodeJS》的Windows借用IOCP实现异步回调过程的一张图片：</p>

<p>其中所要执行的异步回调函数以及相关的所有状态参数会被封装成一个<strong>请求对象</strong>然后被推入到<strong>IO线程池</strong>中，当操作系统执行完IO得到结果之后会将数据放入请求对象中，并归还当前线程至线程池，通知IOCP完成了IO过程，然后<strong>事件循环</strong>从<strong>IO观察者</strong>中得到已经可以执行的请求对象中的回调，灌注IO数据结果开始执行。</p>
<p>Node本身是多线程的，开发人员的JS代码单线程化身为一个老板，实现高效的异步逻辑依靠的是Node机制内部的各个线程池，模拟出了一个异步非阻塞的特点。<strong>呈现在开发人员面前的是表现形式为各种各样的<code>callback</code>组成的一个原生编程风格</strong>。</p>
<h2 id="异步编程与“回调地狱”"><a href="#异步编程与“回调地狱”" class="headerlink" title="异步编程与“回调地狱”"></a>异步编程与“回调地狱”</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">"./test1.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,content1</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fs.readFile(content1, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,content2</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(err);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fs.readFile(content2, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,content3</span>)</span>&#123;</span><br><span class="line">					<span class="keyword">if</span> (err) &#123;</span><br><span class="line">						<span class="built_in">console</span>.log(err);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">console</span>.log(content3)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'主线程'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(content3)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"还没有获取到content3！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取的每一个 .txt 文件中的内容是要读取的下一个文件的路径地址，最后一个txt文件（test3.txt）中的内容是“callback hell is not finished……”</p>
<p>打印结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程</span><br><span class="line">还没有获取到content3！</span><br><span class="line">callback hell is <span class="keyword">not</span> finished<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure>
<p>可以理解为Node代码一根筋的往下想尽快结束所谓的主线程，所以遇到设计异步的就自动忽略并跳过为了往下执行，所以出现了第一句非异步的打印操作，打印“主线程”，再往下执行遇到需要打印 content3 这个变量的时候，主线程就“懵”了，因为命名空间内并没有获取到任何 content3 的数据，甚至在主线程命名空间内都没有定义这个变量，如果不用 try-catch 那么应该会报 “content3 is not defined”的错误。</p>
<p>此外，callback hell 一览无余，一味地因为依赖而采用嵌套回调函数的方式，哪怕是上述代码那么简单的一个原子性的操作都会被这种<strong>“横向发展”</strong>的代码和无休止的大括号嵌套让业务逻辑代码丧失掉可维护性和可读性。</p>
<p>为了避免这种回调地狱，解决问题的方案和第三方模块就开始层出不穷百花齐放了。</p>
<h2 id="这个async不是ES2017的async"><a href="#这个async不是ES2017的async" class="headerlink" title="这个async不是ES2017的async"></a>这个<code>async</code>不是ES2017的<code>async</code></h2><p><a href="https://www.npmjs.com/package/async" target="_blank" rel="noopener">async</a>是一个十分强大，功能十分全面提供异步编程解决法案的一个第三方npm模块。也是我所接触的公司中的项目中大范围使用的。下面是关于这个模块的常用函数使用介绍，先感受一下。</p>
<h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><ul>
<li><strong>async.parallel(tasks,callback)</strong><ul>
<li>tasks 可以是一个数组也可以是个对象，他的数组元素值或者对象的属性值就是一个一个异步的方法。</li>
</ul>
</li>
</ul>
<p>parallel方法用于<strong>并行执行多个方法</strong>，所有传入的方法都是立即执行，方法之间没有数据传递。<strong>传递给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以数组形式传入需要执行的多个方法</span></span><br><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;<span class="comment">//每个function均需要传入一个错误优先的callback</span></span><br><span class="line">        <span class="comment">// 异步函数1，比如 fs.readFile(path,callback)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 异步函数2</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">//最终回调 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当tasks中的任一方法发生错误，即回调形式为callback('错误信息')时，错误将被传递给err参数，未发生错误err参数为空</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> one = results[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> two = results[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//你的各种操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// results中为数组中，两个方法的结果数组：[异步1的结果, 异步2的结果] ，即使第二个方法先执行完成，其结果也是在第一个方法结果之后</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//以object对象形式传入需要执行的多个方法</span></span><br><span class="line"><span class="keyword">async</span>.parallel(&#123;</span><br><span class="line">    one: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 异步函数1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    two: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 异步函数2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当tasks中的任一方法发生错误，即回调形式为callback('错误信息')时，错误将被传递给err参数，未发生错误err参数为空</span></span><br><span class="line">    <span class="comment">// // results 现在等于: &#123;one: 异步1的结果, two: 异步2的结果&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用时所要注意的事项：<ul>
<li>当tasks中的任一方法发生错误时，错误将被传递给最终回调函数的err参数，未发生错误err参数为空。</li>
<li>tasks用数组的写法，即使第二个方法先执行完成，其结果也是在第一个方法结果之后，两个方法的结果数组：[异步1的结果, 异步2的结果]</li>
</ul>
</li>
</ul>
<p>个人感受：这个方法的大量使用让我觉得当一个要展示很多方面的信息的首页时，解耦成了代码可读性的最关键因素，亲身体会的是使用这个方法在企业业务逻辑中理想情况是在 tasks 中注册的并行任务得到的结果最好能够直接使用，而不是在第一个<code>async.parallel</code>的最终回调中依旧需要依赖得到的结果再进行下个系列的异步操作，因为这样导致的结果直接就变成了代码继续向着横向发展，比原生的 callback hell 并没有要好到哪里去。篇幅原因就不展示实际代码了，总之虽然结果流程得到了一个较为明确的控制，但是<strong>依旧没有良好的可读性</strong></p>
<ul>
<li><strong>async.series(tasks,callback)</strong></li>
</ul>
<p>series方法用于<strong>依次执行多个方法</strong>，一个方法执行完毕后才会进入下一方法，<strong>方法之间没有数据传递!!</strong>。</p>
<p>参数和形式与上面的 <code>async.parallel(tasks,callback)</code>一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以数组形式传入需要执行的多个方法</span></span><br><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">       fs.readFile(path1,callback)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">       fs.readFile(path2,callback)</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 可选的最终回调 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当tasks中的任一方法发生错误，即回调形式为callback('错误信息')时，错误将被传递给err参数，未发生错误err参数为空</span></span><br><span class="line">    <span class="comment">// results中为数组中两个方法的结果数组：['one', 'two'] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个方法在 tasks 中注册的异步函数之间虽然没有数据传递，但是这个方法控制了这些个异步方法的执行顺序，并且只要一个函数执行失败了接下来的函数就不会再执行了，并且把 err 传递到最终的回调函数中的 err 参数中。正如它的名字 “series”所说，这个方法有点数据库中的<strong>事务控制</strong>的意思，只不过原生不支持回滚罢了。</p>
<ul>
<li><strong>async.waterfall(tasks,callback)</strong></li>
</ul>
<p>waterfall方法与series方法类似用于<strong>依次执行多个方法</strong>，一个方法执行完毕后才会进入下一方法，不同与series方法的是，waterfall之间有数据传递,<strong>前一个函数的输出为后一个函数的输入</strong>。waterfall的多个方法只能以数组形式传入，不支持object对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'one'</span>, <span class="string">'two'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// arg1 现在是 'one'， arg2 现在是 'two' </span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'three'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// arg1 现在是 'three' </span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'done'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//执行的任务中方法回调err参数时，将被传递至本方法的err参数</span></span><br><span class="line">    <span class="comment">// 参数result为最后一个方法的回调结果'done'     </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为 tasks 中注册的异步函数数组中前一个函数的输出作为后一个输入，很自然的就可以想到可以通过前一个函数传递“处理成功信号”在第二个函数中进行判断来进行一系列完整的简单类似于<strong>事务控制</strong>的逻辑操作。</p>
<ul>
<li><strong>async.auto(tasks,callback)</strong></li>
</ul>
<p>auto方法根据传入的任务类型选择最佳的执行方式。不依赖于其它任务的方法将并发执行，依赖于其它任务的方法将在其执行完成后执行。类似于<strong>“依赖注入”</strong>概念。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.auto(&#123;</span><br><span class="line">    getData: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">         <span class="comment">//一个取数据的方法</span></span><br><span class="line">        <span class="comment">// 与makeFolder方法并行执行</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'data'</span>, <span class="string">'converted to array'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    makeFolder: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 一个创建文件夹的方法</span></span><br><span class="line">        <span class="comment">// 与make_folder方法并行执行</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'folder'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    writeFile: [<span class="string">'getData'</span>, <span class="string">'makeFolder'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback, results</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 此方法在等待getData方法和makeFolder执行完成后执行,并且在results中拿到依赖函数的数据</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'filename'</span>);</span><br><span class="line">    &#125;],</span><br><span class="line">    sendEmail: [<span class="string">'writeFile'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback, results</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 等待writeFile执行完成后执行,results中拿到依赖项的数据</span></span><br><span class="line">        callback(<span class="literal">null</span>, &#123;<span class="string">'file'</span>:results.writeFile, <span class="string">'email'</span>:<span class="string">'user@example.com'</span>&#125;);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err = '</span>, err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'results = '</span>, results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>个人评价：喜欢这种方法，有清晰的可读性，依赖规则以及控制一目了然，<strong>很可惜的是在我们的代码里面并没有使用。</strong>缺点是相比较我们的最终解决方案的优雅，这个还是会有可能嵌套很多层的大括号的方式有它本身的劣势。</p>
<h3 id="异步集合操作"><a href="#异步集合操作" class="headerlink" title="异步集合操作"></a>异步集合操作</h3><ul>
<li><strong>async.each(arr,iterator(item, callback),callback)</strong></li>
</ul>
<p>对数组arr中的每一项执行iterator操作。iterator方法中会传一个当前执行的项及一个回调方法。<strong>each方法中所有对象是并行执行的</strong>。对数组中每一项进行 iterator 函数处理，如果有一项出错则最终的回调的 err 就回事该 err。但是，出错并不会影响到其他的数组元素执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'./Test/file1.txt'</span>,<span class="string">"./Test/file2.txt"</span>,<span class="string">"./Test/file3.txt"</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="function">(<span class="params">item,callback</span>)=&gt;</span>&#123;   </span><br><span class="line">        fs.readFile(item,<span class="string">"utf-8"</span>,(err,results)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(item === <span class="string">"./Test/file2.txt"</span>)&#123;</span><br><span class="line">                callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'wrong'</span>))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(results);</span><br><span class="line">                callback(<span class="literal">null</span>,results)</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;)      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span>.each(arr,iterator,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line"><span class="keyword">Error: </span>wrong</span><br><span class="line">    at fs.readFile (/Users/liulei/Desktop/asyncEach/test.js:10:26)</span><br><span class="line">    at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:511:3)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>可见，由于并发的原因，即是第二项出错，也不会影响其余的元素执行。如果想要让数组中的元素按照顺序执行，并且一旦一个出错，后面的数组元素都将不会执行的情况应该用另一个函数 <strong><code>async.eachSeeries(arr,iterator(item, callback),callback)</code></strong>,用法什么的都一样，这里就不赘述了。</p>
<p>此外，each方法的最终回调函数可以看出来的是，并不会被传入任何结果，所以<strong>最终的回调函数就只有一个参数那就是 err</strong>，如果想要向最终回调函数中传入某些结果那么还要用到接下来介绍的 <code>asycnc.map()</code></p>
<ul>
<li><strong>async.map(arr,iterator(item, callback),callback)</strong></li>
</ul>
<p>map方法使用方式和each完全一样，与each方法不同的是，map方法用于操作对象的转换，转换后的新的结果集会被传递至最终回调方法中（不出错的情况下）呈现一个新的数组的形似。</p>
<p>同样的是，map也是并行操作，如需按顺序并且出错就停止则需要使用 <code>async.mapSeries</code></p>
<h2 id="向Promise的过渡"><a href="#向Promise的过渡" class="headerlink" title="向Promise的过渡"></a>向Promise的过渡</h2><h3 id="Promise基础简要介绍"><a href="#Promise基础简要介绍" class="headerlink" title="Promise基础简要介绍"></a>Promise基础简要介绍</h3><p>一个简单清晰的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">"./Test/file1.txt"</span>, <span class="string">"utf-8"</span>, (err, content) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(<span class="string">"./Test/file2.txt"</span>, <span class="string">"utf-8"</span>, (err, content) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile()</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>只是比原生的callback形式的异步函数多了一步封装包裹的过程。Promise是一个对象，可以把它看做是一个包含着异步函数可能出现的结果（成功或者失败（err））的<strong>“异步状态小球”</strong>。得到了这个小球你就能用 then 去弄他，用 catch 去捕获它的失败。简单的概括，也仅此而已。基于这个小球，我们就能得到所谓的“现代异步处理方案”了，后话。</p>
<p>前端 Promisify Ajax请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>)</span><br><span class="line"><span class="keyword">let</span> getData = <span class="function">(<span class="params">api</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        req.open(<span class="string">"GET"</span>,api,<span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line">        req.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(req.responseText)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText))</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        req.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              reject(<span class="keyword">new</span> Erro(req.statusText))</span><br><span class="line">            &#125;</span><br><span class="line">            req.send()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    getData(<span class="string">'/api'</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> content=<span class="built_in">JSON</span>.parse(res).msg</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerText = content</span><br><span class="line">            &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Node提供的原生模块的API基本上都是基于一个 callback 形式的函数，我们想用 Promise ，难不成甚至原生的这些最原始的函数都要我们手动去进行 return 一个 Promise 对象的改造？其实不是这样的，Node 风格的 callback 都遵从着“错误优先”的回到函数方案，即形如<code>(err,res)=&gt;{}</code>，并且回调函数都是最后一个参数，他们的形式都是一致的。所以Node的原生<a href="http://nodejs.cn/api/util.html#util_util_promisify_original" target="_blank" rel="noopener">util</a>模块提供了一个方便我们将函数 Promisfy 的工具——<code>util.promisfy(origin)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> readFileSeccond = util.promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">readFileSeccond(<span class="string">"./Test/file3.txt"</span>,<span class="string">"utf-8"</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意，这个原生工具会对原生回调的结果进行封装，如果在最后的回调函数中除了 err 参数之外，还有不止一个结果的情况，那么 util.promisify 会将结果都统一封装进一个对象之中。</strong></p>
<h3 id="用Promise提供方法应对不同的情况"><a href="#用Promise提供方法应对不同的情况" class="headerlink" title="用Promise提供方法应对不同的情况"></a>用Promise提供方法应对不同的情况</h3><p>实际代码逻辑中我们可能会面对各种异步流程控制的情况，像是之前介绍 async 模块一样，一种很常见的情况就是有很多的异步方法是可以同时并发发起请求的，即互相不依赖对方的结果，<code>async.parallel</code>的效果那样。Promise 除了封装异步之外还未我们提供了一些原生方法去面对类似这样的情况：</p>
<h4 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h4><ul>
<li>Promise.resolve(value)</li>
</ul>
<p>它是下面这段代码的语法糖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意点，在 then 调用的时候<strong>即便一个promise对象是立即进入完成状态的，那Promise的 then 调用也是异步的</strong>，这是为了避免同步和异步之间状态出现了模糊。所以你可以认为，<strong>Promise 只能是异步的</strong>，用接下的代码说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1.构造Promise函数"</span>);</span><br><span class="line">    resolve(<span class="string">"ray is handsome"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promiseA.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2.成功态"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"3.最后书写"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码，打印的结果如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造Promise函数</span><br><span class="line"><span class="number">3.</span>最后书写</span><br><span class="line"><span class="number">2.</span>成功态</span><br><span class="line">ray is handsome</span><br></pre></td></tr></table></figure>
<p>promise 可以链式 then ，每一个 then 之后都会产生一个新的 promise 对象，在 then 链中前一个 then 这种可以通过 <code>return</code>的方式想下一个 then 传递值，这个值会自动调用 <code>promise.resolve()</code>转化成一个promise对象，代码说明吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">promise</span><br><span class="line">    .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value)</span><br><span class="line">            <span class="keyword">return</span> value+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`first那里传下来的<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> value+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`second那里传下来的<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码答应的结果：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">first那里传下来的<span class="number">2</span></span><br><span class="line">second那里传下来的<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>此外 then 链中应该添加 catch 捕获异常，<strong>某一个 then 中出现了错误则执行链会跳过后来的 then 直接进入 catch</strong> </p>
<h4 id="得到-async-parallel同样的效果"><a href="#得到-async-parallel同样的效果" class="headerlink" title="得到 async.parallel同样的效果"></a>得到 <code>async.parallel</code>同样的效果</h4><p>Promise 提供了一个<strong>原生方法 Promise.all(arr)</strong>,其中arr是一个由 promise 对象组成的一个数组。该方法可以<strong>实现让传入该方法的数组中的 promise 同时执行，并在所有的 promise 都有了最终的状态之后，才会调用接下来的 then 方法，并且得到的结果和在数组中注册的结果保持一致</strong>。看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> files = [readFile(<span class="string">"../../Test/file1.txt"</span>,<span class="string">"utf-8"</span>),</span><br><span class="line">            readFile(<span class="string">"../../Test/file2.txt"</span>,<span class="string">"utf-8"</span>),</span><br><span class="line">            readFile(<span class="string">"../../Test/file3.txt"</span>,<span class="string">"utf-8"</span>),]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(files)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码最终会打印,即是按顺序的三个txt文件里面的内容组成的数组：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[‘<span class="number">1</span>’,‘<span class="number">2</span>’,‘<span class="number">3</span>’]</span><br></pre></td></tr></table></figure>
<p>对比 <code>async.parallel</code>的用法，发现得到相同的结果。</p>
<p>此外，与 <code>Promise.all</code>方法相对应的还有一个<strong>Promise.race</strong>，该方法与all用法相同，同样是传入一个由 promise 对象组成的数组，你可以把上面的代码中的 all 直接换成 race 看看是什么效果。没错，对于指导 race 这个英文单词意思的可能已经猜出来了，race 竞争，赛跑，就是只要数组中有一个 promise 到达最终态，该方法的 then 就会执行。所以该代码有可能会出现’1’,’2’,’3’中的任何一个字符串。</p>
<p>至此，我们解决了要改造的代码的第一个问题，那就是多异步的同时执行，那么之前 async 模块介绍的其他的的功能在实际运用中也很常见的几个场景，类似顺序执行异步函数，异步集合操作要怎么使用新的方案模拟出来呢？真正的原生 <strong>async</strong>要登场了。</p>
<h2 id="所谓的异步流程控制的“终极解决方案”————async"><a href="#所谓的异步流程控制的“终极解决方案”————async" class="headerlink" title="所谓的异步流程控制的“终极解决方案”————async"></a>所谓的异步流程控制的“终极解决方案”————async</h2><p>在开始介绍 async 之前，想先聊一种情况。</p>
<p>基于 Promise 的这一套看似可以让代码“竖着写”，可以很好的解决“callbackHell”回调地狱的窘境，但是上述所有的例子都是简单场景下。在基于 Promise 的 then 链中我们不难发现，虽然一层层往下的 then 链可以向下一层传递本层处理好的数据，但是这种链条并不能跨层使用数据，就是说如果第3层的 then 想直接使用第一层的结果必须有一个前提就是第二层不仅将自己处理好的数据 <code>return</code> 给第三层，同时还要把第一层传下来的再一次传给第三层使用。不然还有一种方式，那就是我们从回调地狱陷入另一种地狱 “Promise地狱”。</p>
<p>借用这篇<a href="https://juejin.im/entry/58523b908e450a006c4d0c5b" target="_blank" rel="noopener">博客</a> 的一个操作 mongoDB 场景例子说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MongoClient.connect(url + db_name).then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.collection(<span class="string">'blogs'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">coll</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> coll.find().toArray();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">blogs</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(blogs.length);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果我想要在最后一个 then 中得到 db 对象用来执行 <code>db.close()</code>关闭数据库操作，我只能选择让每一层都传递这个 db 对象直至我使用操作 then 的尽头，像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MongoClient.connect(url + db_name).then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">db</span>:db,<span class="attr">coll</span>:db.collection(<span class="string">'blogs'</span>)&#125;;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">db</span>:result.db,<span class="attr">blogs</span>:result.coll.find().toArray()&#125;;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result.blogs.then(<span class="function"><span class="params">blogs</span> =&gt;</span> &#123;   <span class="comment">//注意这里，result.coll.find().toArray()返回的是一个Promise，因此这里需要再解析一层</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">db</span>:result.db,<span class="attr">blogs</span>:blogs&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.blogs.length);</span><br><span class="line">    result.db.close();</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面陷入 “Promise地狱”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MongoClient.connect(url + db_name).then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> coll = db.collection(<span class="string">'blogs'</span>);</span><br><span class="line">    coll.find().toArray().then(<span class="function"><span class="params">blogs</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(blogs.length);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>看上去不是那么明显，但是<strong>已经出现了 then 里面嵌套 then 了</strong>，操作一多直接一夜回到解放前，再一次丧失了让人想看代码的欲望。OK，用传说中的 async 呢</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">await</span> MongoClient.connect(url + db_name);</span><br><span class="line">    <span class="keyword">let</span> coll = db.collection(<span class="string">'blogs'</span>);</span><br><span class="line">    <span class="keyword">let</span> blogs = <span class="keyword">await</span> coll.find().toArray();</span><br><span class="line">    <span class="built_in">console</span>.log(blogs.length);</span><br><span class="line">    db.close();</span><br><span class="line">&#125;)().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>各种异步写的像同步</strong>了，<code>async</code>（异步）关键字声明，告诉读代码的这是一个包含了各种异步操作的函数，<code>await</code>（得等它）关键字说明后面的是个异步操作，卡死了等他执行完再往下。这个语义以及视觉确实没法否认这可能是“最好的”异步解决方案了吧。</p>
<h3 id="不得不提的-co-模块"><a href="#不得不提的-co-模块" class="headerlink" title="不得不提的 co 模块"></a>不得不提的 co 模块</h3><p>众所周知的是 async 函数式 generator 的语法糖，generator 在异步流程控制中的执行依赖于执行器，co 模块就是一个 generator 的执行器，在真正介绍和使用 async 解决法案之前有必要简单了解一下大名鼎鼎的 co 模块。</p>
<p><strong>什么是 generator</strong>，详细请参考<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Ecmascript6 入门</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行生成器，返回一个生成器内部的指针</span></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="comment">//手动 generator 执行器</span></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码采用 generator 的方式在 yeild 关键字后面封装了异步操作并通过 <code>next()</code>去手动执行它。调用 g.next() 是去执行 yield 后面的异步，这个方案就是经典的异步的“协程”（多个线程互相协作，完成异步任务）处理方案。</p>
<p>协程执行步骤：</p>
<ol>
<li>协程A开始执行。</li>
<li>协程A执行到一半，进入暂停，执行权转移到协程B。</li>
<li>（一段时间后）协程B交还执行权。</li>
<li>协程A恢复执行。</li>
</ol>
<p><strong>协程遇到 yield 命令就暂停</strong> 等到执行权返回，再从暂停的地方继续往后执行。</p>
<p>翻译上述代码：</p>
<ul>
<li><code>gen()</code>执行后返回一个生成器的内部执行指针，gen 生成器就是一个协程。</li>
<li><code>gen.next()</code>让生成器内部开始执行代码到遇到 yield 执行 yield 后，就暂停该协程，并且交出执行权，此时执行权落到了JS主线程的手里，即开始执行 Promise 的 then 解析。</li>
<li>then 的回调里取得了该异步数据结果，调用<code>g.next(data)</code>通过网<code>next()</code>函数传参的形式，将结果返回给生成器的<code>f1</code>变量。</li>
<li>依次回调类推。</li>
</ul>
<p>说明：</p>
<ul>
<li><code>g.next()</code>返回一个对象，形如<code>{ value: 一个Promise, done: false }</code>到生成器内部代码执行完毕返回<code>{ value: undefined, done: true }</code></li>
</ul>
<p>引出一个问题: 我们不能每一次用 generator 处理异步都要手写  generator 的 then 回调执行器，该格式相同，每次都是调用<code>.next()</code>,所以可以用递归函数封装成一个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上述执行器的函数编写 co 模块考虑周全的写好了，<a href="https://github.com/tj/co/blob/master/index.js" target="_blank" rel="noopener">co模块源码</a></p>
<p>你只需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure>
<p><code>yield</code> 后面的是并发。</p>
<p>此时我们来对比 async 写法:)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> [</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;().catch(onerror);</span><br></pre></td></tr></table></figure>
<p>async 函数就是将 Generator 函数的星号（<em>）替换成 async，将 yield 替换成 await，仅此而已。并且它不需要额外的执行器，因为它<em>*自带 Generator 执行器</em></em></p>
<p>本质上其实并没有脱离“协程”异步的处理方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="keyword">await</span> readFile(<span class="string">'./test1.txt'</span>,<span class="string">"utf-8"</span>)</span><br><span class="line">	<span class="keyword">var</span> b = <span class="keyword">await</span> readFile(<span class="string">'./test2.txt'</span>,<span class="string">"utf-8"</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;)()</span><br><span class="line">.catch(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"出错了"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'主线程'</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果会先输出“主线程”。</p>
<h3 id="async-解决方案"><a href="#async-解决方案" class="headerlink" title="async 解决方案"></a>async 解决方案</h3><p>前文我们通过 <code>Promise.all()</code>解决了 <code>async.paralle()</code>的功能，现在我们来看看用 Promise 配合原生 async 来达到“async”模块的其他功能。</p>
<ul>
<li>实现 async.series 顺序执行异步函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码</span></span><br><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (version.other_parameters != otherParams) &#123; <span class="comment">// 更新其他参数</span></span><br><span class="line">                <span class="keyword">var</span> newVersion = &#123;</span><br><span class="line">                    id: version.id,</span><br><span class="line">                    other_parameters: otherParams,</span><br><span class="line">                &#125;;</span><br><span class="line">                CVersion.update(newVersion, callback);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            cVersionModel.removeParams(version.id, toBeRemovedParams, callback);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            cVersionModel.addParams(version.id, toBeAddedParams, callback);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            CVersion.get(version.id, callback);</span><br><span class="line">        &#125;,</span><br><span class="line">    ], <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            logger.error(<span class="string">"更新电路图参数失败！"</span>);</span><br><span class="line">            logger.error(version);</span><br><span class="line">            logger.error(tagNames);</span><br><span class="line">            logger.error(err);</span><br><span class="line">            callback(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback(<span class="literal">null</span>, results[<span class="number">3</span>].parameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//新代码</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version.other_parameters != otherParams) &#123; <span class="comment">// 更新其参数</span></span><br><span class="line">        <span class="keyword">var</span> newVersion = &#123;</span><br><span class="line">            id: version.id,</span><br><span class="line">            other_parameters: otherParams,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">await</span>  CVersion.update(newVersion, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> cVersionModel.removeParams(version.id, toBeRemovedParams)</span><br><span class="line">    <span class="keyword">await</span> cVersionModel.addParams(version.id, toBeAddedParams)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> CVersion.get(version.id)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)()</span><br><span class="line">..catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">	logger.error(<span class="string">"更新参数失败！"</span>);</span><br><span class="line">    logger.error(version);</span><br><span class="line">    logger.error(tagNames);</span><br><span class="line">    logger.error(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>实现 async.each 的遍历集合每一个元素实现异步操作功能：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码</span></span><br><span class="line">Notification.newNotifications= <span class="function"><span class="keyword">function</span>(<span class="params">notifications, callback</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">notification, callback</span>) </span>&#123;</span><br><span class="line">        Notification.newNotification(notification, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">            logger.error(err);</span><br><span class="line">            callback(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span>.each(notifications, iterator, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        callback(err, <span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新代码</span></span><br><span class="line">Notification.newNotifications= <span class="function"><span class="keyword">function</span>(<span class="params">notifications）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  notifications.forEach(async function(notification</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">await</span> Notification.newNotification(notification)<span class="comment">//异步操作</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">           logger.error(err);</span><br><span class="line">           <span class="keyword">return</span> err;</span><br><span class="line">        &#125;    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码需要说明的情况是，在forEach 体内的每一个元素的 await 都是并发执行的，因为这正好满足了 <code>async.each</code> 的特点，如果你希望的是<strong>数组元素继发执行异步操作</strong>，也就是前文所提到的 <code>async.eachSeries</code> 的功能，你需要协程一个 for 循环而不是 forEach 的形式，类似如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);<span class="comment">//异步数据库操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你觉得上述并发集合操作使用 forEach 的方式依旧不太直观，也可以改为配合<code>Promise.all</code>的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码现先对数组元素进行遍历，将传入了数组元素参数的一步操作封装成为一个数组，通过<code>await Promise.all(promises)</code>的形式进行并发操作。<strong>Tips：</strong> <code>Promise.all</code> 有自动将数组的每个元素变成Promise对象的能力。</p>
<h3 id="应用-async-异步解决方案的现代工具————puppeteer"><a href="#应用-async-异步解决方案的现代工具————puppeteer" class="headerlink" title="应用 async 异步解决方案的现代工具————puppeteer"></a>应用 async 异步解决方案的现代工具————puppeteer</h3><p>Puppeteer是一个Node库，它是提供了一组用来操纵Chrome的API的工具，默认headless 为 true 也就是无UI的chrome，也可以配置为有UI即打开一个可视化浏览器。所以他又叫传说中的“无头浏览器”。</p>

                <blockquote>
                    本文为原创文章作为学习交流笔记，如有错误请您评论指教 <br/>
                    转载请注明来源：<a href="https://isliulei.com/article/Node异步流程控制实践与总结/" rel="noopener" title="https://isliulei.com/article/Node异步流程控制实践与总结/">https://isliulei.com/article/Node异步流程控制实践与总结/</a>
                    </blockquote>
                <hr>

               
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/NPM小记/" data-toggle="tooltip" data-placement="top" title="一篇 NPM 小记">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/总结HTTP的缓存机制与原理/" data-toggle="tooltip" data-placement="top" title="总结HTTP的缓存机制与原理">Next Post &rarr;</a>
                        </li>
                    
                </ul>
    <!-- github isuue comment container-->
    
        <hr>
        <div id="git-container"></div>
    
            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://huangxuan.me" target="_blank">Hux Blog</a></li>
                    
                        <li><a href="https://zoumiaojiang.com" target="_blank">ZouMiaojiang Blog</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>


<!-- gitcoment JS代码 -->

    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
    <script>
    var gitment = new Gitment({
      id: 'https://isliulei.com/article/Node异步流程控制实践与总结/', // 可选。默认为 location.href
      owner: 'ray1121',
      repo: 'ray1121.github.io',
      oauth: {
        client_id: '0dec358cb186e06c3ed5',
        client_secret: '2e4b2be32341a8a745d1841f0b1fcb8fe0da42c5',
      },
    })
    gitment.render('git-container')
    </script>
    <!-- gitcoment 代码结束 -->
    



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                



                

                
                    <li>
                        <a target="_blank"  href="https://github.com/ray1121">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank"  href="https://juejin.im/user/5a2a2ed9f265da43085df03d">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-stack-1x fa-inverse">掘</i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank"  href="https://segmentfault.com/blog/liulei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-stack-1x fa-inverse">sf</i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="http://weibo.com/2866571714">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Ray 2018 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://isliulei.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-113342470-1';
    var _gaDomain = 'isliulei.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- 百度连接连接提交 -->
<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>

<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




    <a id="rocket" href="#top" class=""></a>
<!-- Image to hack wechat -->
<img src="https://isliulei.com/img/icon_wechat.jpg" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->
<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
</body>

</html>
